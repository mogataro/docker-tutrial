<!DOCTYPE html>
<html>

<body>

  <h1>Dockerコンテナの実行</h1>

  <h2>hello-worldコンテナの実行と動作の解説</h2>

  <p>ターミナルから以下のコマンドを実行する</p>
  <pre>
    <code>
      docker run hello-world
    </code>
  </pre>

  <p>dockerの部分はdockerコマンドで、runはその後ろに記述されたイメージを取得してイメージからコンテナを起動するサブコマンドです。</p>
  <p>このコマンドの場合はhello-worldというイメージを取得してコンテナを起動します。</p>
  <P>docker run hello-worldと打つとDockerコマンドはDockerデーモンに接続してhello-worldのイメージを探します。<br />
    最初はhello-worldのイメージはPC上には存在しないのでインターネットを経由して、Docker HubというDocker社がホスティングしているサーバーに探しに行きます。<br />
    Docker Hub上にhello-worldイメージが見つかったらイメージをダウンロードしてPC上に保存します。<br />
    保存したイメージを基にコンテナを起動してコンテナに定義されたコマンドを実行します。<br />
    実行結果は最終的にDockerクライアントに送られターミナルの画面に表示されます。<br />
    同じイメージがPC上に存在する場合はPC上に存在するイメージからコンテナを起動するのでもっと早く処理が終わります。
  </P>

  <p>
    <code>docker run</code>コマンドは複数のDockerコマンドをまとめて実行したのと同じ意味があります。<br />
    イメージがPCに存在しない場合にDocker Hubにイメージを取得しに行った部分は<code>docker pull</code>コマンドが同じことが行えます。<br />
    コンテナ作成のみを行う部分は<code>docker create</code>コマンドがあり、<br />
    コンテナを起動するコマンドに<code>docker start</code>コマンドがあります。
  </p>

  <h2>Docker Hubとは</h2>

  <p>Docker HubとはDockerイメージのレジストリサービスでDocker Hubを経由してDockerイメージの公開 検索ダウンロードを行うことができます。</p>
  <p>
    Docker Hubのurlは<a src="https://hub.docker.com" target="_blank">https://hub.docker.com</a>です。
  </p>
  <p>Docker Hubにアカウントを作成しておく事で自身で作成したイメージを公開することもできます。</p>
  <p>Docker Hubに上がってるイメージにはオフィシャルのものと 個人や組織で独自に公開しているものがあります。<br />
    イメージ名がスラッシュで区切られていないものがオフィシャルのイメージです。<br />
    スラッシュで区切られているものはスラッシュより前に個人や組織名が入っておりスラッシュの後にイメージ名がつながっている形になっています。<br />
    オフィシャルなイメージはDocker社によってレビューが行われておりセキュリティ的な面やイメージサイズなどの面でチェックが入っています。<br />
    また、オフィシャルなリポジトリの場合リポジトリ詳細ページの上にOFFICIAL REPOSITORYと記載されています。<br />
  </p>
  <p>
    詳細ページのTagsタブにはリポジトリに含まれるイメージがタグ付けされて管理されています。<br />
    <code>docker run hello-world</code>のように使用するイメージ名のみ指定していた場合は自動的にhello-worldのリポジトリのlatestタグのイメージがダウンロードされます。<br />
    明示的にイメージタグを指定してコンテナを実行する場合は<code>docker run hello-world:latest</code>のように、イメージ名をコロンで区切ってタグ名を指定します。
  </p>

  <h2>Dockerイメージとは</h2>

  <p>Dockerイメージとは特定のコンテナを実行するのに必要なファイルをまとめたファイルシステムです。<br />
    一般的にイメージに含まれるものとしてOSのライブラリやアプリケーションなどがあります。<br />
    例えばwebサーバーのコンテナを作る場合にはnginxやApacheが既にインストールされているイメージが使用できます。<br />
    プログラムの実行環境についても同様でPHPやRubyの実行環境が欲しい場合はこれらのイメージからコンテナを作成すれば簡単に実行環境を用意することができます。
  </p>

  <p>
    必ずしも最初から必要なソフトウェアが含まれるイメージを用意する必要はなく自身で作成することもできます。<br />
    イメージのファイルシステムに使用されるストレージドライバーとしてはAUFSなどが挙げられレイヤーという階層構造でデータが管理される少々特殊なファイルシステムとなっています。<br />
    そしてイメージのデータはレイヤーで構成され全て読み取り専用で編集することはできない作りになっています。
  </p>

  <h3>Dockerイメージのファイルシステム</h3>

  <div>
    <img src="img/docker_002.png" alt="Dockerイメージのファイルシステムの図" title="Dockerイメージのファイルシステム">
  </div>

  <p>
    左の図はDockerイメージの図で右がそのイメージから作成したコンテナの図です。<br />
    イメージは階層構造でデータが管理されており各層のことをレイヤーと呼びます。<br />
    Dockerのイメージのレイヤーは一種のコマンドを実行するたびに階層が積み重ねられていきます。<br />
    例えばDockerイメージにnginxをインストールするコマンドを実行すればそれが一つの階層として作られ、<br />
    設定ファイルはイメージ内にコピーした場合にさらにもうひとつの階層が作られるようなイメージです。<br />
    なお、一度作成したイメージのレイヤーは全て読み取り専用となっており変更を加えることはできません。
  </p>

  <p>
    右の図は、Dockerイメージを基にコンテナを起動すると新たに新しく読み書き可能なコンテナレイヤーという層が作られます。<br />
    dockerイメージからコンテナを起動してコンテナレイヤー上にファイルの追加や削除やパッケージの追加など行い、それをまたイメージとして保存することも可能です。
  </p>

  <p>
    注意すべき点は、過去のレイヤーで追加したファイルをコンテナレイヤーで削除して新しいイメージを作成したとしても過去のレイヤーからファイルが消えないことです。<br />
    削除を実行したコンテナレイヤー上で削除コマンドが実行されファイルが削除されますが、履歴として過去のレイヤーには残り続けるのであるレイヤーでファイルを追加した処理はそのまま残り続けます。<br />
    よって一度大きなファイルを追加してイメージ化したものをあとのレイヤーで削除したとしてもイメージにはその大きなファイルは残り続けるのでイメージ全体のサイズは変わることはありません。<br />
    Dockerコンテナはなるべく軽量にサイズを抑えることが重要とされているため、無駄なファイルがイメージの中に含まれないようにイメージを作成することが大事です。<br />
    Dockerイメージが大きくなるということはイメージのダウンロードやDocker Hubへのアップロードに時間がかかるようになります。
  </p>


  <h3>Dockerイメージの継承</h3>

  <p>
    Dockerイメージの特徴として複数のイメージで継承関係を作ることができるという点があります。
  </p>

  <div>
    <img src="img/docker_003.png" alt="Dockerのイメージ継承の図1" title="Dockerのイメージ継承 その1">
  </div>

  <p>
    この例はベースイメージとしてCent OSのベースイメージを使用してRubyの実行環境のイメージを作成する場合です。<br />
    ベースイメージとは何も継承していない起点となるDockerイメージのことを言います。<br />
    このようにCent OSのイメージに追加した形でRubyの実行環境をインストールしたイメージを作ることができます。
  </p>

  <div>
    <img src="img/docker_004.png" alt="Dockerのイメージ継承の図2" title="Dockerのイメージ継承 その2">
  </div>

  <p>
    これは先ほどのRubyの実行環境を持ったイメージを継承しRubyのフレームワークであるRailsのレイヤーを加えた例です。<br />
    Dockerイメージはうまく使っていくことでベースイメージから機能別にイメージを構築し、最終的にアプリケーションのレイヤーを加えていくことができます。
  </p>

  <h3>同じイメージを継承した場合のメリット</h3>

  <div>
    <img src="img/docker_005.png" alt="同じDockerイメージを継承するメリットの図" title="同じDockerイメージを継承するメリット">
  </div>

  <p>
    同じCent OSのイメージを継承したRubyの実行環境のイメージとMySQLのイメージがあるとします。<br />
    互いに同じイメージを利用している場合全く同じレイヤーの部分については同じレイヤーのデータを参照します。<br />
    こちらの場合はCent OSのイメージに含まれるレイヤーはひとつしか持たずRubyのイメージとMySQLのイメージで共有してCent OSのイメージを使用するということです。<br />
    これにより使用するイメージサイズが小さくなりストレージの節約につながります。<br />
    また２重にレイヤーのデータを用意する必要がなくなるので既にCent OSのイメージが存在する場合はサブのRubyのレイヤーやMySQLのレイヤーだけ取得すればよくイメージ取得の通信料も抑えることができます。
  </p>

  <h2>whalesayコンテナの実行とDockerイメージダウンロードの動作</h2>

</body>

</html>